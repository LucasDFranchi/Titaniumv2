import argparse
import json
import os

def argument_parser():
    """
    Parses command-line arguments for the script.

    Returns:
        Namespace: Contains parsed arguments including input file path,
        board variant, and output file path.
    """
    parser = argparse.ArgumentParser(description="Process some inputs.")
    
    parser.add_argument('-i', '--input', type=str, required=True, help="Input file path")
    parser.add_argument('-b', '--board_variant', type=str, required=True, help="Specify which hardware variant is been used")
    parser.add_argument('-o', '--output', type=str, required=False, default="./", help="Output file path")
    
    return parser.parse_args()

def generate_cpp_header(board):
    """
    Generates a C++ header file content based on the provided board configuration.

    Args:
        board (dict): A dictionary containing the board configuration,
        including GPIO, SPI, and I2C pin definitions.

    Returns:
        str: The generated C++ header content.
    """
    header_content = []
    
    header_content.append("/* This file is autogenerated. Do not edit manually. It is generated*/")
    header_content.append("/* before the build process based on the board configuration */")
    header_content.append("#pragma once\n")

    header_content.append("#pragma once\n")
    header_content.append('#include "driver/gpio.h"')
    header_content.append('#include "driver/spi_common.h"')
    header_content.append('#include "driver/i2c.h"\n')

    board_struct_name = "BoardConfig"

    if 'gpio_pins' in board:
        header_content.append("typedef enum gpio_id_t{")
        for pin_info in board["gpio_pins"].values():
            header_content.append(f"\t{pin_info['name']} = GPIO_NUM_{pin_info['number']},")
        header_content.append("} gpio_id_et;\n")

    header_content.append(f"namespace {board_struct_name} {{\n")

    # GPIO Pins
    if 'gpio_pins' in board:
        gpio_nums_list = ",\n".join(f"\t\t\t{pin_info['name']}" for pin_info in board["gpio_pins"].values())
        gpio_modes_list = ",\n ".join(f"\t\t\tGPIO_MODE_{pin_info['direction'].upper()}" for pin_info in board["gpio_pins"].values())

        header_content.append("    // GPIO Pins")
        header_content.append("    static constexpr uint8_t CONFIGURED_PINS = {};".format(len(board["gpio_pins"])))
        header_content.append("    static constexpr gpio_id_et PINS_NAME[] = {")
        header_content.append(f"{gpio_nums_list}")
        header_content.append("\t\t};\n")

        header_content.append("    static constexpr gpio_mode_t PINS_MODE[] = {")
        header_content.append(f"{gpio_modes_list}")
        header_content.append("\t\t};\n")

    # SPI Pins
    has_spi_configured = "true" if 'spi_pins' in board else "false"
    header_content.append("    // SPI Pins")
    header_content.append(f"    static constexpr bool CONFIGURED_SPI = {has_spi_configured};")
    if has_spi_configured:
        header_content.append(f"    static constexpr spi_host_device_t SPI_HOST_DEVICE = SPI{board['spi_pins']['spi_host']}_HOST;")
        header_content.append(f"    static constexpr gpio_num_t SPI_MOSI = GPIO_NUM_{board['spi_pins']['mosi']};")
        header_content.append(f"    static constexpr gpio_num_t SPI_MISO = GPIO_NUM_{board['spi_pins']['miso']};")
        header_content.append(f"    static constexpr gpio_num_t SPI_SCK = GPIO_NUM_{board['spi_pins']['sck']};")

    # I2C Pins
    has_i2c_configured = "true" if 'i2c_pins' in board else "false"
    header_content.append("    // I2C Pins\n")
    header_content.append(f"    static constexpr bool CONFIGURED_I2C = {has_i2c_configured};")
    if 'i2c_pins' in board:
        header_content.append(f"    static constexpr gpio_num_t I2C_SDA = GPIO_NUM_{board['i2c_pins']['sda']};")
        header_content.append(f"    static constexpr gpio_num_t I2C_SCL = GPIO_NUM_{board['i2c_pins']['scl']}\n;")

    header_content.append("};  // namespace BoardConfig\n")
    
    return "\n".join(header_content)

def read_input_json(filepath):
    """
    Reads a JSON configuration file and returns the parsed data.

    Args:
        filepath (str): The path to the JSON file.

    Returns:
        dict: The parsed JSON data.
    """
    config_data = None

    with open(filepath, 'r') as json_file:
        config_data = json.load(json_file)

    return config_data

def write_output_json(filepath, header_code):
    """
    Writes the generated C++ header code to a specified file.

    Args:
        filepath (str): The directory path where the header file will be saved.
        header_code (str): The C++ header content to write to the file.
    """
    with open(os.path.join(filepath, "BoardHeader.hpp"), 'w') as header_file:
        header_file.write(header_code)

def main():
    """
    Main function that orchestrates the parsing of arguments,
    reading of the JSON configuration, generating the C++ header,
    and writing it to an output file.
    """
    args = argument_parser()

    json_config = read_input_json(args.input)
    boards_config = json_config.get("boards")

    board_config = next((board for board in boards_config if board.get("name") == args.board_variant), None)
    header_code = generate_cpp_header(board_config)
    write_output_json(args.output, header_code)


if __name__ == "__main__":
    main()

